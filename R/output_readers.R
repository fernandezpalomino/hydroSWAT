# =============================================================================
# Family: Output readers
# Reading SWAT outputs and gauge files (output_rch, output_sub, output_hru,
# get_swat_vars, read_pcp, read_tmp)
# =============================================================================

# -------------------------------------------------------------------------
# output_rch
# -------------------------------------------------------------------------
#' @title Read SWAT reach output
#'
#' @description
#' Reads the \code{output.rch} file generated by SWAT, allowing users to filter
#' the data by variables, reach IDs, and time steps (daily or monthly).
#'
#' @param file Character. Absolute path to the \code{output.rch} file. Default
#' is "output.rch".
#' @param variable Character vector with the names of variables to read. Use
#' \code{\link{get_swat_vars}("rch")} to list all options. If \code{NULL}, all
#' variables are read.
#' @param target_id Numeric vector of reach IDs to extract. Default \code{NULL}
#' retrieves all reaches.
#' @param time_step Character. Time step of the simulation ("daily" or
#' "monthly"). Default is "daily".
#' @param output_start_date Character. Date when SWAT output generation begins
#' (first day after warm-up), in "yyyy-mm-dd" format.
#'
#' @return A \code{data.frame} with the selected variables for each reach and
#' time step. Columns "RCH" (reach ID) and "MON" (Date) are always included.
#'
#' @family Output readers
#' @importFrom dplyr %>%
#' @importFrom readr read_fwf fwf_widths
#' @export
#'
#' @examples
#' # Example with package data
#' tmpdir <- tempdir()
#' get_swat_example(tmpdir)
#' rch_file <- file.path(tmpdir, "TxtInOut", "output.rch")
#' rch_data <- output_rch(file = rch_file, variable = c("FLOW_OUTcms"),
#'                        target_id = NULL, time_step = "daily",
#'                        output_start_date = "2011-01-01")
#' head(rch_data)
#'
#' \dontrun{
#' # Example with external SWAT project
#' rch_data <- output_rch(file = "C:/SWAT_Project/TxtInOut/output.rch",
#'                        variable = c("FLOW_OUTcms"), target_id = 5,
#'                        time_step = "monthly",
#'                        output_start_date = "2000-01-01")
#' }

output_rch <- function(
    file = "output.rch",
    variable = NULL,
    target_id = NULL,
    time_step = "daily",
    output_start_date
) {
  # Check if the file exists
  if (!file.exists(file)) stop(file, " doesn't exist.")
  # Validate time_step input
  if (!time_step %in% c("daily", "monthly")) stop("'time_step' must be 'daily' or 'monthly'.")
  # Validate output_start_date format
  if (!grepl("^\\d{4}-\\d{2}-\\d{2}$", output_start_date)) {
    stop("Invalid 'output_start_date' format. Please use 'yyyy-mm-dd'.")
  }
  # Validate target_id
  if (!is.null(target_id) && !is.numeric(target_id)) {
    stop("'target_id' should be an integer vector.")
  }
  # Define all available variables

  variable_all <- get_swat_vars("rch")

  # Define column widths based on SWAT format rev == "692"
  widths_var <- c(6, 4, 8 + 1, 5+1, rep(12, 59))
  #5000 format ('REACH ',i4,1x,i8,1x,i5,59e12.4)
  widths <- c(6, 5+1, 8+1, 5, rep(12, 59))

  names(widths_var) <- variable_all
  names(widths) <- variable_all

  # Check if requested variables are valid
  if (!is.null(variable)) {
    if (!all(variable %in% variable_all)) {
      invalid_vars <- variable[!variable %in% variable_all]
      stop("Invalid variable(s): ", paste(invalid_vars, collapse = ", "), " do not exist in '", basename(file), "'")
    }
  }

  # Read variables from the output.rch file
  output_var <- unlist(readr::read_fwf(file = file, readr::fwf_widths(abs(widths_var)), skip = 8, n_max = 1, show_col_types = FALSE)[1, ])
  output_var[1] <- "COLNAME"
  output_var <- output_var[!is.na(output_var)]

  # Adjust variable names based on SWAT revision
  # "SEDCONCmg/kg" was changed into "SEDCONCmg/L" in Rev 653

  if("SEDCONCmg/kg" %in% output_var){
    output_var[which(output_var == "SEDCONCmg/kg")] <- "SEDCONCmg/L"
  }


  # Filter columns to read based on variable positions
  col_po <- readr::fwf_widths(widths[output_var], col_names = names(widths[output_var]))
  if (!is.null(variable)) {
    col_po <- col_po %>% dplyr::filter(col_names %in% c("RCH", "MON", variable))
  }

  # Read and arrange data based on the time step
  if (time_step == "monthly") {
    output_values <- readr::read_fwf(file = file, col_po, skip = 9, show_col_types = FALSE) %>%
      dplyr::mutate(MON = as.numeric(MON)) %>%
      dplyr::filter(MON <= 12) %>%
      dplyr::arrange(RCH) %>%
      base::split(.$RCH) %>%
      lapply(function(x) dplyr::mutate(x, MON = seq.Date(as.Date(output_start_date), length.out = nrow(x), by = "month"))) %>%
      dplyr::bind_rows()

  } else if (time_step == "daily") {
    output_values <- readr::read_fwf(file = file, col_po, skip = 9, show_col_types = FALSE) %>%
      dplyr::arrange(RCH) %>%
      base::split(.$RCH) %>%
      lapply(function(x) dplyr::mutate(x, MON = seq.Date(as.Date(output_start_date), length.out = nrow(x), by = "day"))) %>%
      dplyr::bind_rows()
  }

  # Filter by reach ID if specified
  if (!is.null(target_id)) {
    if (!all(target_id %in% output_values$RCH)) {
      invalid_ids <- target_id[!target_id %in% output_values$RCH]
      stop("Reach ID(s): ", paste(invalid_ids, collapse = ", "), " do not exist in output.rch")
    }
    output_values <- output_values %>% dplyr::filter(RCH %in% target_id)
  }

  return(output_values)
}


# -------------------------------------------------------------------------
# output_sub
# -------------------------------------------------------------------------
#' @title Read SWAT subbasin output
#'
#' @description
#' Reads the \code{output.sub} file generated by SWAT, allowing users to filter
#' the data by variables, subbasin IDs, and time steps (daily or monthly).
#'
#' @param file Character. Absolute path to the \code{output.sub} file. Default
#' is "output.sub".
#' @param variable Character vector with the names of variables to read. Use
#' \code{\link{get_swat_vars}("sub")} to list all options. If \code{NULL}, all
#' variables are read.
#' @param target_id Numeric vector of subbasin IDs to extract. Default
#' \code{NULL} retrieves all subbasins.
#' @param time_step Character. Time step of the simulation ("daily" or
#' "monthly"). Default is "daily".
#' @param output_start_date Character. Date when SWAT output generation begins
#' (first day after warm-up), in "yyyy-mm-dd" format.
#'
#' @return A \code{data.frame} with the selected variables for each subbasin and
#' time step. Columns "SUB" (subbasin ID) and "MON" (Date) are always included.
#'
#' @family Output readers
#' @importFrom dplyr %>%
#' @importFrom readr read_fwf fwf_widths
#' @export
#'
#' @examples
#' # Example with package data
#' tmpdir <- tempdir()
#' get_swat_example(tmpdir)
#' sub_file <- file.path(tmpdir, "TxtInOut", "output.sub")
#' sub_data <- output_sub(file = sub_file, variable = c("PRECIPmm", "ETmm", "WYLDmm"),
#'                        target_id = NULL, time_step = "daily",
#'                        output_start_date = "2011-01-01")
#' head(sub_data)
#'
#' \dontrun{
#' # Example with external SWAT project
#' sub_data <- output_sub(file = "C:/SWAT_Project/TxtInOut/output.sub",
#'                        variable = c("WYLDmm"), target_id = c(1, 2),
#'                        time_step = "daily",
#'                        output_start_date = "2000-01-01")
#' }

output_sub <- function(
    file = "output.sub",
    variable = NULL,
    target_id = NULL,
    time_step = "daily",
    output_start_date
) {
  # Check if the file exists
  if (!file.exists(file)) stop("'", file, "' doesn't exist")

  # Validate time_step input
  if (!time_step %in% c("daily", "monthly")) stop("'time_step' must be 'daily' or 'monthly'")

  # Validate output_start_date format
  if (!grepl("^\\d{4}-\\d{2}-\\d{2}$", output_start_date)) {
    stop("Invalid 'output_start_date' format. Please use 'yyyy-mm-dd'.")
  }

  # Validate target_id
  if (!is.null(target_id) && !is.numeric(target_id)) {
    stop("'target_id' should be an integer vector.")
  }
  # Define all available variables
  variable_all <- get_swat_vars("sub")

  # Define column widths based on SWAT revision
  rev_number <- as.numeric(gsub(".*Rev (\\d+).*", "\\1", readLines(file, n = 2)[2]))

  if (rev_number <= 664) {
    widths_var <- c(6, 4 + 1, 8 + 1, 4, 10, rep(10, 24))
    widths <- c(6, 4 + 1, 8, 1 + 4, 10, rep(10, 18), 1 + 10, rep(10, 5))
  } else {
    # SWAT Fortran rev 692
    widths_var <- c(6, 4, 8 + 1, 5, 10, rep(10, 24))
    widths <- c(6, 5 + 1, 8, 1 + 4, 10, rep(10, 18), 1 + 10, rep(10, 5))
  }

  names(widths_var) <- variable_all
  names(widths) <- variable_all

  # Read variables from the output.sub file
  output_var <- unlist(readr::read_fwf(file = file, readr::fwf_widths(abs(widths_var)), skip = 8, n_max = 1, show_col_types = FALSE)[1, ])
  output_var[1] <- "COLNAME"
  output_var <- output_var[!is.na(output_var)]

  # Check if requested variables are valid
  if (!is.null(variable)) {
    if (!all(variable %in% variable_all)) {
      invalid_vars <- variable[!variable %in% variable_all]
      stop("Invalid variable(s): ", paste(invalid_vars, collapse = ", "), " do not exist in '", basename(file), "'")
    }
  }

  # Filter columns to read based on variable positions
  col_po <- readr::fwf_widths(widths[output_var], col_names = names(widths[output_var]))
  if (!is.null(variable)) {
    col_po <- col_po %>% dplyr::filter(col_names %in% c("SUB", "MON", variable))
  }

  # Read and arrange data based on the time step
  if (time_step == "monthly") {
    output_values <- suppressWarnings(
      readr::read_fwf(file = file, col_po, skip = 9, show_col_types = FALSE) %>%
        dplyr::mutate(MON = as.numeric(MON)) %>%
        dplyr::filter(!is.na(MON)) %>%
        dplyr::filter(MON <= 12) %>%
        dplyr::arrange(SUB) %>%
        base::split(.$SUB) %>%
        lapply(function(x) dplyr::mutate(x, MON = seq.Date(as.Date(output_start_date), length.out = nrow(x), by = "month"))) %>%
        dplyr::bind_rows()
    )
  } else if (time_step == "daily") {
    output_values <- suppressWarnings(
      readr::read_fwf(file = file, col_po, skip = 9, show_col_types = FALSE) %>%
        dplyr::arrange(SUB) %>%
        base::split(.$SUB) %>%
        lapply(function(x) dplyr::mutate(x, MON = seq.Date(as.Date(output_start_date), length.out = nrow(x), by = "day"))) %>%
        dplyr::bind_rows()
    )
  }

  # Filter by subbasin ID if specified
  if (!is.null(target_id)) {
    if (!all(target_id %in% output_values$SUB)) {
      invalid_ids <- target_id[!target_id %in% output_values$SUB]
      stop("Subbasin ID(s): ", paste(invalid_ids, collapse = ", "), " do not exist in output.sub")
    }
    output_values <- output_values %>% dplyr::filter(SUB %in% target_id)
  }

  return(output_values)
}


# -------------------------------------------------------------------------
# output_hru
# -------------------------------------------------------------------------
#' @title Read SWAT HRU output
#'
#' @description
#' Reads the \code{output.hru} file generated by SWAT, allowing users to filter
#' the data by variables, subbasin IDs, HRU IDs, and time steps (daily or
#' monthly).
#'
#' @param file Character. Absolute path to the \code{output.hru} file. Default
#' is "output.hru".
#' @param variable Character vector with the names of variables to read. Use
#' \code{\link{get_swat_vars}("hru")} to list all options. If \code{NULL}, all
#' variables are read.
#' @param target_id Character vector of HRU IDs (HRUGIS). Default \code{NULL}
#' retrieves all HRUs.
#' @param time_step Character. Time step of the simulation ("daily" or
#' "monthly"). Default is "daily".
#' @param output_start_date Character. Date when SWAT output generation begins
#' (first day after warm-up), in "yyyy-mm-dd" format.
#'
#' @return A \code{data.frame} with the selected variables for each HRU and time
#' step. Columns "LULC", "HRU", "GIS", "SUB", and "MON" are always included.
#'
#' @family Output readers
#' @importFrom dplyr %>%
#' @importFrom readr read_fwf fwf_widths
#' @export
#'
#' @examples
#' # Example with package data
#' tmpdir <- tempdir()
#' get_swat_example(tmpdir)
#' hru_file <- file.path(tmpdir, "TxtInOut", "output.hru")
#' hru_data <- output_hru(file = hru_file, variable = c("PRECIPmm", "ETmm", "WYLDmm"),
#'                        target_id = NULL, time_step = "daily",
#'                        output_start_date = "2011-01-01")
#' head(hru_data)
#'
#' \dontrun{
#' # Example with external SWAT project
#' hru_data <- output_hru(file = "C:/SWAT_Project/TxtInOut/output.hru",
#'                        variable = NULL, target_id = NULL,
#'                        time_step = "monthly",
#'                        output_start_date = "2000-01-01")
#' }


output_hru <- function(
    file = "output.hru",
    variable = NULL,
    target_id = NULL,
    time_step = "daily",
    output_start_date
) {
  # Check if the file exists
  if (!file.exists(file)) stop("'", file, "' doesn't exist.")

  # Validate time_step input
  if (!time_step %in% c("daily", "monthly")) {
    stop("'time_step' must be 'daily' or 'monthly'.")
  }

  # Validate output_start_date format
  if (!grepl("^\\d{4}-\\d{2}-\\d{2}$", output_start_date)) {
    stop("Invalid 'output_start_date' format. Please use 'yyyy-mm-dd'.")
  }

  # Define all available variables
  variable_all <- get_swat_vars("hru")

  # Define column widths based on SWAT format Rev 692
  # 1000 format (a4,i5,1x,a5,a4,i5,1x,i4,1x,i4,e10.5,66f10.3,1x,
  #*e10.5,1x,e10.5,8e10.3,3f10.3)

  widths_var <- c(4, 5, 10, 5, 5, 5, 10, rep(10, 79))
  names(widths_var) <- variable_all

  widths <- c(4, 5, 10, 5, 5, 5, 10, rep(10, 66), rep(11, 2), rep(10, 11))
  names(widths) <- variable_all

  # Define column types
  col_type <- c("c", "i", "c", "i", "i", "d", "d", rep("d", 66), "d", "d", rep("d", 8), rep("d", 3))
  names(col_type) <- variable_all

  # Read variables from the output.hru file
  output_var <- unlist(readr::read_fwf(file = file, readr::fwf_widths(abs(widths_var)), skip = 8, n_max = 1, show_col_types = FALSE)[1, ])
  output_var <- output_var[!is.na(output_var)]

  # Define column positions for the required variables
  #col_po <- readr::fwf_widths(widths_var[output_var], col_names = names(widths_var[output_var]))
  col_po <- readr::fwf_widths(widths[output_var], col_names = names(widths[output_var]))

  col_type <- col_type[output_var]

  # Check if specific variables are requested
  if (!is.null(variable)) {
    if (!all(variable %in% variable_all)) {
      stop("Invalid variable argument: '", variable[!variable %in% variable_all], "' does (do) not exist in '", basename(file), "'")
    }
    # Filter column positions and types based on requested variables
    col_po <- col_po %>% dplyr::filter(col_names %in% c("LULC", "HRU", "GIS", "SUB", "MON", variable))
    col_type <- col_type[names(col_type) %in% c("LULC", "HRU", "GIS", "SUB", "MON", variable)]
  }

  # Transform column types to a compatible format
  col_type <- cols2(col_type)

  # Read file and rearrange the data table based on the time step
  if (time_step == "monthly") {
    output_values <- readr::read_fwf(file = file, col_po, skip = 9, col_types = col_type) %>%
      dplyr::mutate(MON = as.numeric(MON)) %>%
      dplyr::filter(!is.na(MON)) %>%
      dplyr::filter(MON <= 12) %>%
      dplyr::arrange(HRU) %>%
      base::split(.$HRU) %>%
      lapply(function(x) dplyr::mutate(x, MON = seq.Date(as.Date(output_start_date), length.out = nrow(x), by = "month"))) %>%
      dplyr::bind_rows()

  } else if (time_step == "daily") {
    output_values <- readr::read_fwf(file = file, col_po, skip = 9, col_types = col_type) %>%
      dplyr::arrange(HRU) %>%
      base::split(.$HRU) %>%
      lapply(function(x) dplyr::mutate(x, MON = seq.Date(as.Date(output_start_date), length.out = nrow(x), by = "day"))) %>%
      dplyr::bind_rows()
  }

  # Filter the data based on user inputs for HRUs

  if (!is.null(target_id)) {
    if (!all(target_id %in% output_values$GIS)) {
      stop("HRUGIS id : '", target_id[!target_id %in% output_values$GIS], "' does (do) not exist in output.hru")
    }
    output_values <- output_values %>%
      dplyr::filter(GIS %in% target_id)
  }

  return(output_values)
}


# -------------------------------------------------------------------------
# get_swat_vars
# -------------------------------------------------------------------------
#' @title Retrieve SWAT output variables
#'
#' @description
#' Returns a list of SWAT output variables by category (reach, subbasin, or HRU),
#' or all combined. Useful for filtering when reading SWAT output files.
#'
#' @param type Character. Category of variables to return:
#' \itemize{
#'   \item{"all"}: Returns all available variables (default).
#'   \item{"rch"}: Returns variables related to reach output.
#'   \item{"sub"}: Returns variables related to subbasin output.
#'   \item{"hru"}: Returns variables related to hydrologic response units (HRU).
#' }
#'
#' @return A character vector of variable names for the selected category. If
#' \code{"all"} is selected, a list of vectors for each category is returned.
#'
#' @family Output readers
#' @export
#'
#' @examples
#' # Get all SWAT variables (list by category)
#' get_swat_vars("all")
#'
#' # Get variables for Reach (output.rch)
#' get_swat_vars("rch")
#'
#' # Get variables for Subbasin (output.sub)
#' get_swat_vars("sub")
#'
#' # Get variables for HRU (output.hru)
#' get_swat_vars("hru")
get_swat_vars <- function(type = c("all", "rch", "sub", "hru")) {
  # Match the type argument to ensure valid input
  type <- match.arg(type)  # Validates the 'type' argument

  vars <- list(
    rch = c("COLNAME", "RCH", "GIS", "MON", "AREAkm2", "FLOW_INcms",
            "FLOW_OUTcms", "EVAPcms", "TLOSScms", "SED_INtons",
            "SED_OUTtons", "SEDCONCmg/L", "ORGN_INkg", "ORGN_OUTkg",
            "ORGP_INkg", "ORGP_OUTkg", "NO3_INkg", "NO3_OUTkg",
            "NH4_INkg", "NH4_OUTkg", "NO2_INkg", "NO2_OUTkg",
            "MINP_INkg", "MINP_OUTkg", "CHLA_INkg", "CHLA_OUTkg",
            "CBOD_INkg", "CBOD_OUTkg", "DISOX_INkg", "DISOX_OUTkg",
            "SOLPST_INmg", "SOLPST_OUTmg", "SORPST_INmg", "SORPST_OUTmg",
            "REACTPSTmg", "VOLPSTmg", "SETTLPSTmg", "RESUSP_PSTmg",
            "DIFFUSEPSTmg", "REACBEDPSTmg", "BURYPSTmg", "BED_PSTmg",
            "BACTP_OUTct", "BACTLP_OUTct", "CMETAL#1kg", "CMETAL#2kg",
            "CMETAL#3kg", "TOT Nkg", "TOT Pkg", "NO3ConcMg/l", "WTMPdegc",
            "Salt1", "Salt2", "Salt3", "Salt4", "Salt5", "Salt6", "Salt7",
            "Salt8", "Salt9", "Salt10", "SAR", "EC"),

    sub = c("COLNAME", "SUB", "GIS", "MON", "AREAkm2", "PRECIPmm",
            "SNOMELTmm", "PETmm", "ETmm", "SWmm", "PERCmm", "SURQmm",
            "GW_Qmm", "WYLDmm", "SYLDt/ha", "ORGNkg/ha", "ORGPkg/ha",
            "NSURQkg/ha", "SOLPkg/ha", "SEDPkg/ha", "LAT Q(mm)",
            "LATNO3kg/h", "GWNO3kg/ha", "CHOLAmic/L", "CBODU mg/L",
            "DOXQ mg/L", "TNO3kg/ha", "QTILEmm", "TVAPkg/ha"),

    hru = c("LULC", "HRU", "GIS", "SUB", "MGT", "MON", "AREAkm2",
            "PRECIPmm", "SNOFALLmm", "SNOMELTmm", "IRRmm", "PETmm",
            "ETmm", "SW_INITmm", "SW_ENDmm", "PERCmm", "GW_RCHGmm",
            "DA_RCHGmm", "REVAPmm", "SA_IRRmm", "DA_IRRmm", "SA_STmm",
            "DA_STmm", "SURQ_GENmm", "SURQ_CNTmm", "TLOSSmm", "LATQGENmm",
            "GW_Qmm", "WYLDmm", "DAILYCN", "TMP_AVdgC", "TMP_MXdgC",
            "TMP_MNdgC", "SOL_TMPdgC", "SOLARMJ/m2", "SYLDt/ha", "USLEt/ha",
            "N_APPkg/ha", "P_APPkg/ha", "NAUTOkg/ha", "PAUTOkg/ha",
            "NGRZkg/ha", "PGRZkg/ha", "NCFRTkg/ha", "PCFRTkg/ha",
            "NRAINkg/ha", "NFIXkg/ha", "F-MNkg/ha", "A-MNkg/ha", "A-SNkg/ha",
            "F-MPkg/ha", "AO-LPkg/ha", "L-APkg/ha", "A-SPkg/ha", "DNITkg/ha",
            "NUPkg/ha", "PUPkg/ha", "ORGNkg/ha", "ORGPkg/ha", "SEDPkg/ha",
            "NSURQkg/ha", "NLATQkg/ha", "NO3Lkg/ha", "NO3GWkg/ha", "SOLPkg/ha",
            "P_GWkg/ha", "W_STRS", "TMP_STRS", "N_STRS", "P_STRS", "BIOMt/ha",
            "LAI", "YLDt/ha", "BACTPct", "BACTLPct", "WTAB_CLIm", "WTAB_SOLm",
            "SNOmm", "CMUPkg/ha", "CMTOTkg/ha", "QTILEmm", "TNO3kg/ha",
            "LNO3kg/ha", "GW_Q_Dmm", "LATQCNTmm", "TVAPkg/ha")
  )

  # Return all variables if "all" is selected, or the specific category
  if (type == "all") {
    return(vars)
  } else {
    return(vars[[type]])
  }
}


# -------------------------------------------------------------------------
# read_pcp
# -------------------------------------------------------------------------
#' @title Read precipitation data from SWAT .pcp files
#'
#' @description
#' Reads one or more SWAT `.pcp` files containing daily precipitation data and
#' associated metadata for precipitation gauges such as station IDs, subbasins,
#' and their latitude, longitude, and elevation. These files use a fixed-width
#' format: the first four lines store station IDs and metadata, and the remaining
#' lines contain daily values (year, day of year, and precipitation for each
#' station).
#'
#' @param pcp Character vector with paths to one or more `.pcp` files in SWAT
#'   format.
#'
#' @return A list with two tibbles:
#' \itemize{
#'   \item \code{gauges}: Metadata for each gauge (subbasin, station ID, latitude,
#'     longitude, elevation).
#'   \item \code{pcp}: Daily precipitation (year, day of year, and values for
#'     each station).
#' }
#'
#' @examples
#' # Example with package data
#' tmpdir <- tempdir()
#' get_swat_example(tmpdir)
#' pcp_file <- file.path(tmpdir, "TxtInOut", "pcp1.pcp")
#' pcp_data <- read_pcp(pcp_file)
#' head(pcp_data$gauges)
#' head(pcp_data$pcp)
#'
#' \dontrun{
#' # Example with external files
#' pcp_files <- list.files("path/to/TxtInOut", pattern = "\\.pcp$", full.names=TRUE)
#' pcp_data <- read_pcp(pcp_files)
#' }
#' @family Output readers
#' @importFrom readr fwf_widths read_fwf
#' @importFrom dplyr bind_rows mutate_if mutate as_tibble %>%
#' @importFrom plyr join_all
#' @export



read_pcp <- function(pcp) {
  gauges <- list()
  pcp_files <- list()
  gauges_per_file <- c(0)

  for (z in 1:length(pcp)) {
    #read gauges attributes
    l <- readLines(pcp[z])

    Station <- strsplit(l[1], " ")[[1]][3] %>%
      strsplit(., ",") %>% .[[1]]


    Lati <- substr(l[2], 8, nchar(l[2]))
    Lati <- sapply(seq(from=1, to=nchar(Lati), by=5), function(i) substr(Lati, i, i+4))

    Long <- substr(l[3], 8, nchar(l[3]))
    Long <- sapply(seq(from=1, to=nchar(Long), by=5), function(i) substr(Long, i, i+4))

    Elev <- substr(l[4], 8, nchar(l[4]))
    Elev <- sapply(seq(from=1, to=nchar(Elev), by=5), function(i) substr(Elev, i, i+4))

    Subbasin <- as.character(as.numeric(substr(Station, 5, 10)))

    gauge_desc <- data.frame(Subbasin=Subbasin,
                             Station=Station,
                             Lati=Lati,
                             Long=Long,
                             Elev=Elev,
                             stringsAsFactors = F) %>%
      as_tibble() %>%
      mutate(Lati=as.numeric(Lati), Long=as.numeric(Long), Elev=as.numeric(Elev)) %>%
      mutate(ID_swat= (gauges_per_file + 1):(gauges_per_file + length(Subbasin)))

    gauges[[z]] <- gauge_desc

    gauges_per_file[1] <- gauges_per_file + length(Station)

    # read pcp

    widths <- c(4, 3, rep(5, length(Station)))
    names(widths) <- c("year", "yday", Station)

    col_po <- readr::fwf_widths(widths,
                                col_names = names(widths))

    output_values <- readr::read_fwf(file = pcp[z], col_po, skip = 4, show_col_types = FALSE)
    output_values <-  output_values %>%
      mutate_if(is.character, as.numeric)

    pcp_files[[z]] <- output_values

  }

  gauges_all <- gauges %>% bind_rows()
  pcp_all <- plyr::join_all(pcp_files, type='left') %>% as_tibble()

  return(list(
    gauges = gauges_all,
    pcp = pcp_all
  ))
}


# -------------------------------------------------------------------------
# read_tmp
# -------------------------------------------------------------------------
#' @title Read temperature data from SWAT .tmp files
#'
#' @description
#' Reads one or more SWAT `.tmp` files containing daily maximum and minimum
#' temperature data and associated metadata for temperature gauges such as
#' station IDs, subbasins, and their latitude, longitude, and elevation. These
#' files use a fixed-width format: the first four lines store station IDs and
#' metadata, and the remaining lines contain daily values (year, day of year,
#' and maximum and minimum temperatures for each station).
#'
#' @param tmp Character vector with paths to one or more `.tmp` files in SWAT
#'   format.
#'
#' @return A list with three tibbles:
#' \itemize{
#'   \item \code{gauges}: Metadata for each gauge (subbasin, station ID, latitude,
#'     longitude, elevation).
#'   \item \code{tmax}: Daily maximum temperature (year, day of year, values for
#'     each station).
#'   \item \code{tmin}: Daily minimum temperature (year, day of year, values for
#'     each station).
#' }
#'
#' @examples
#' # Example with package data
#' tmpdir <- tempdir()
#' get_swat_example(tmpdir)
#' tmp_file <- file.path(tmpdir, "TxtInOut", "tmp1.tmp")
#' tmp_data <- read_tmp(tmp_file)
#' head(tmp_data$gauges)
#' head(tmp_data$tmax)
#' head(tmp_data$tmin)
#'
#' \dontrun{
#' # Example with external files
#' tmp_files <- list.files("path/to/TxtInOut", pattern = "\\.tmp$", full.names=TRUE)
#' tmp_data <- read_tmp(tmp_files)
#' }
#' @family Output readers
#' @importFrom readr fwf_widths read_fwf
#' @importFrom dplyr bind_rows mutate_if mutate as_tibble %>%
#' @importFrom plyr join_all
#' @export


read_tmp <- function(tmp) {
  gauges <- list()
  tmp_files <- list()
  gauges_per_file <- c(0)

  for (z in 1:length(tmp)) {
    l <- readLines(tmp[z])

    Station <- strsplit(l[1], " ")[[1]][3] %>%
      strsplit(., ",") %>% .[[1]]


    Lati <- substr(l[2], 8, nchar(l[2]))
    Lati <- sapply(seq(from=1, to=nchar(Lati), by=10), function(i) substr(Lati, i, i+9))

    Long <- substr(l[3], 8, nchar(l[3]))
    Long <- sapply(seq(from=1, to=nchar(Long), by=10), function(i) substr(Long, i, i+9))

    Elev <- substr(l[4], 8, nchar(l[4]))
    Elev <- sapply(seq(from=1, to=nchar(Elev), by=10), function(i) substr(Elev, i, i+9))

    Subbasin <- as.character(as.numeric(substr(Station, 5, 10)))

    gauge_desc <- data.frame(Subbasin=Subbasin,
                             Station=Station,
                             Lati=Lati,
                             Long=Long,
                             Elev=Elev,
                             stringsAsFactors = F) %>%
      tibble::as_tibble() %>%
      dplyr::mutate(Lati=as.numeric(Lati),
                    Long=as.numeric(Long),
                    Elev=as.numeric(Elev)) %>%
      dplyr::mutate(
        ID_swat= (gauges_per_file + 1):(gauges_per_file + length(Station))
      )

    gauges[[z]] <- gauge_desc

    gauges_per_file[1] <- gauges_per_file + length(Station)

    # read tmp

    widths <- c(4, 3, rep(5, length(Station)*2))
    names(widths) <- c("year", "yday",
                       lapply(Station, function(x) paste0(x, c("_tmax", "_tmin"))) %>%
                         unlist()
    )

    col_po <- readr::fwf_widths(widths,
                                col_names = names(widths))


    output_values <- readr::read_fwf(file = tmp[z], col_po, skip = 4,
                                     show_col_types = FALSE)
    output_values <-  output_values %>%
      dplyr::mutate_if(is.character, as.numeric)

    tmp_files[[z]] <- output_values

  }

  gauges_all <- gauges %>%
    dplyr::bind_rows()

  gauges_all <- gauges_all %>%
    dplyr::mutate(tmax = paste0(Station, "_tmax"), tmin = paste0(Station, "_tmin"))

  tmp_all <- plyr::join_all(tmp_files, type='left') %>%
    tibble::as_tibble()

  tmax <- tmp_all[, c(1, 2, seq(from = 3, by = 2, length.out = nrow(gauges_all)))]

  tmin <- tmp_all[, c(1, 2, seq(from = 4, by = 2, length.out = nrow(gauges_all)))]


  return(list(
    gauges = gauges_all,
    tmax = tmax,
    tmin = tmin
  ))
}
